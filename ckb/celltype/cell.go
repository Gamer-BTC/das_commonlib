// Generated by Molecule 0.6.1

package celltype
import (
    "bytes"
    "errors"
    "strconv"
    "strings"
       )

type ActionDataBuilder struct {
    action Bytes
params Bytes
}
        

func (s *ActionDataBuilder) Build() ActionData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.action.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.params.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.action.AsSlice())
b.Write(s.params.AsSlice())
    return ActionData{inner: b.Bytes()}
}
                

func (s *ActionDataBuilder) Action(v Bytes) *ActionDataBuilder {
    s.action = v
    return s
}
            

func (s *ActionDataBuilder) Params(v Bytes) *ActionDataBuilder {
    s.params = v
    return s
}
            

func NewActionDataBuilder() *ActionDataBuilder {
	return &ActionDataBuilder{ action: BytesDefault(),params: BytesDefault() }
}
    

type ActionData struct {
    inner []byte
}
        

func ActionDataFromSliceUnchecked(slice []byte) *ActionData {
    return &ActionData{inner: slice}
}
func (s *ActionData) AsSlice() []byte {
    return s.inner
}
            

func ActionDataDefault() ActionData {
    return *ActionDataFromSliceUnchecked([]byte{ 20,0,0,0,12,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ActionDataFromSlice(slice []byte, compatible bool) (*ActionData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
        return &ActionData{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ActionData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ActionData{inner: slice}, nil
}
            

func (s *ActionData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ActionData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ActionData) Len() uint {
    return s.FieldCount()
}
func (s *ActionData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ActionData) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ActionData) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ActionData) Action() *Bytes {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ActionData) Params() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ActionData) AsBuilder() ActionDataBuilder {
    ret := NewActionDataBuilder().Action(*s.Action()).Params(*s.Params())
    return *ret
}
        

type ConfigCellMainBuilder struct {
    account_expiration_grace_period Uint32
min_ttl Uint32
type_id_table TypeIdTable
}
        

func (s *ConfigCellMainBuilder) Build() ConfigCellMain {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_expiration_grace_period.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.min_ttl.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_expiration_grace_period.AsSlice())
b.Write(s.min_ttl.AsSlice())
b.Write(s.type_id_table.AsSlice())
    return ConfigCellMain{inner: b.Bytes()}
}
                

func (s *ConfigCellMainBuilder) AccountExpirationGracePeriod(v Uint32) *ConfigCellMainBuilder {
    s.account_expiration_grace_period = v
    return s
}
            

func (s *ConfigCellMainBuilder) MinTtl(v Uint32) *ConfigCellMainBuilder {
    s.min_ttl = v
    return s
}
            

func (s *ConfigCellMainBuilder) TypeIdTable(v TypeIdTable) *ConfigCellMainBuilder {
    s.type_id_table = v
    return s
}
            

func NewConfigCellMainBuilder() *ConfigCellMainBuilder {
	return &ConfigCellMainBuilder{ account_expiration_grace_period: Uint32Default(),min_ttl: Uint32Default(),type_id_table: TypeIdTableDefault() }
}
    

type ConfigCellMain struct {
    inner []byte
}
        

func ConfigCellMainFromSliceUnchecked(slice []byte) *ConfigCellMain {
    return &ConfigCellMain{inner: slice}
}
func (s *ConfigCellMain) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainDefault() ConfigCellMain {
    return *ConfigCellMainFromSliceUnchecked([]byte{ 96,1,0,0,16,0,0,0,20,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,72,1,0,0,40,0,0,0,72,0,0,0,104,0,0,0,136,0,0,0,168,0,0,0,200,0,0,0,232,0,0,0,8,1,0,0,40,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainFromSlice(slice []byte, compatible bool) (*ConfigCellMain, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
        return &ConfigCellMain{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMain", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMain{inner: slice}, nil
}
            

func (s *ConfigCellMain) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMain) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMain) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMain) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMain) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMain) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMain) AccountExpirationGracePeriod() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMain) MinTtl() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMain) TypeIdTable() *TypeIdTable {
    var ret *TypeIdTable
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = TypeIdTableFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = TypeIdTableFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMain) AsBuilder() ConfigCellMainBuilder {
    ret := NewConfigCellMainBuilder().AccountExpirationGracePeriod(*s.AccountExpirationGracePeriod()).MinTtl(*s.MinTtl()).TypeIdTable(*s.TypeIdTable())
    return *ret
}
        

type TypeIdTableBuilder struct {
    apply_register_cell Hash
pre_account_cell Hash
proposal_cell Hash
ref_cell Hash
account_cell Hash
on_sale_cell Hash
bidding_cell Hash
primary_market_cell Hash
wallet_cell Hash
}
        

func (s *TypeIdTableBuilder) Build() TypeIdTable {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (9 + 1)
    offsets := make([]uint32, 0, 9)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ref_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.on_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.bidding_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.primary_market_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.wallet_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.apply_register_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
b.Write(s.ref_cell.AsSlice())
b.Write(s.account_cell.AsSlice())
b.Write(s.on_sale_cell.AsSlice())
b.Write(s.bidding_cell.AsSlice())
b.Write(s.primary_market_cell.AsSlice())
b.Write(s.wallet_cell.AsSlice())
    return TypeIdTable{inner: b.Bytes()}
}
                

func (s *TypeIdTableBuilder) ApplyRegisterCell(v Hash) *TypeIdTableBuilder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) PreAccountCell(v Hash) *TypeIdTableBuilder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) ProposalCell(v Hash) *TypeIdTableBuilder {
    s.proposal_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) RefCell(v Hash) *TypeIdTableBuilder {
    s.ref_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) AccountCell(v Hash) *TypeIdTableBuilder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) OnSaleCell(v Hash) *TypeIdTableBuilder {
    s.on_sale_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) BiddingCell(v Hash) *TypeIdTableBuilder {
    s.bidding_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) PrimaryMarketCell(v Hash) *TypeIdTableBuilder {
    s.primary_market_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) WalletCell(v Hash) *TypeIdTableBuilder {
    s.wallet_cell = v
    return s
}
            

func NewTypeIdTableBuilder() *TypeIdTableBuilder {
	return &TypeIdTableBuilder{ apply_register_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault(),ref_cell: HashDefault(),account_cell: HashDefault(),on_sale_cell: HashDefault(),bidding_cell: HashDefault(),primary_market_cell: HashDefault(),wallet_cell: HashDefault() }
}
    

type TypeIdTable struct {
    inner []byte
}
        

func TypeIdTableFromSliceUnchecked(slice []byte) *TypeIdTable {
    return &TypeIdTable{inner: slice}
}
func (s *TypeIdTable) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableDefault() TypeIdTable {
    return *TypeIdTableFromSliceUnchecked([]byte{ 72,1,0,0,40,0,0,0,72,0,0,0,104,0,0,0,136,0,0,0,168,0,0,0,200,0,0,0,232,0,0,0,8,1,0,0,40,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableFromSlice(slice []byte, compatible bool) (*TypeIdTable, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 9 == 0 {
        return &TypeIdTable{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTable", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 9 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 9 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTable{inner: slice}, nil
}
            

func (s *TypeIdTable) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTable) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTable) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTable) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTable) CountExtraFields() uint {
    return s.FieldCount() - 9
}

func (s *TypeIdTable) HasExtraFields() bool {
    return 9 != s.FieldCount()
}
            

func (s *TypeIdTable) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) ProposalCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) RefCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) AccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) OnSaleCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) BiddingCell() *Hash {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) PrimaryMarketCell() *Hash {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) WalletCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[36:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[40:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTable) AsBuilder() TypeIdTableBuilder {
    ret := NewTypeIdTableBuilder().ApplyRegisterCell(*s.ApplyRegisterCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).RefCell(*s.RefCell()).AccountCell(*s.AccountCell()).OnSaleCell(*s.OnSaleCell()).BiddingCell(*s.BiddingCell()).PrimaryMarketCell(*s.PrimaryMarketCell()).WalletCell(*s.WalletCell())
    return *ret
}
        

type ConfigCellRegisterBuilder struct {
    apply_min_waiting_block_number Uint32
apply_max_waiting_block_number Uint32
account_max_length Uint32
char_sets CharSetList
price_configs PriceConfigList
proposal_min_confirm_interval Uint8
proposal_min_extend_interval Uint8
proposal_min_recycle_interval Uint8
proposal_max_account_affect Uint32
proposal_max_pre_account_contain Uint32
profit ProfitConfig
discount DiscountConfig
}
        

func (s *ConfigCellRegisterBuilder) Build() ConfigCellRegister {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (12 + 1)
    offsets := make([]uint32, 0, 12)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_min_waiting_block_number.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_max_waiting_block_number.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_max_length.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.char_sets.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price_configs.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_min_confirm_interval.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_min_extend_interval.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_min_recycle_interval.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_max_account_affect.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_max_pre_account_contain.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.profit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.discount.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.apply_min_waiting_block_number.AsSlice())
b.Write(s.apply_max_waiting_block_number.AsSlice())
b.Write(s.account_max_length.AsSlice())
b.Write(s.char_sets.AsSlice())
b.Write(s.price_configs.AsSlice())
b.Write(s.proposal_min_confirm_interval.AsSlice())
b.Write(s.proposal_min_extend_interval.AsSlice())
b.Write(s.proposal_min_recycle_interval.AsSlice())
b.Write(s.proposal_max_account_affect.AsSlice())
b.Write(s.proposal_max_pre_account_contain.AsSlice())
b.Write(s.profit.AsSlice())
b.Write(s.discount.AsSlice())
    return ConfigCellRegister{inner: b.Bytes()}
}
                

func (s *ConfigCellRegisterBuilder) ApplyMinWaitingBlockNumber(v Uint32) *ConfigCellRegisterBuilder {
    s.apply_min_waiting_block_number = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) ApplyMaxWaitingBlockNumber(v Uint32) *ConfigCellRegisterBuilder {
    s.apply_max_waiting_block_number = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) AccountMaxLength(v Uint32) *ConfigCellRegisterBuilder {
    s.account_max_length = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) CharSets(v CharSetList) *ConfigCellRegisterBuilder {
    s.char_sets = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) PriceConfigs(v PriceConfigList) *ConfigCellRegisterBuilder {
    s.price_configs = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) ProposalMinConfirmInterval(v Uint8) *ConfigCellRegisterBuilder {
    s.proposal_min_confirm_interval = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) ProposalMinExtendInterval(v Uint8) *ConfigCellRegisterBuilder {
    s.proposal_min_extend_interval = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) ProposalMinRecycleInterval(v Uint8) *ConfigCellRegisterBuilder {
    s.proposal_min_recycle_interval = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) ProposalMaxAccountAffect(v Uint32) *ConfigCellRegisterBuilder {
    s.proposal_max_account_affect = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) ProposalMaxPreAccountContain(v Uint32) *ConfigCellRegisterBuilder {
    s.proposal_max_pre_account_contain = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) Profit(v ProfitConfig) *ConfigCellRegisterBuilder {
    s.profit = v
    return s
}
            

func (s *ConfigCellRegisterBuilder) Discount(v DiscountConfig) *ConfigCellRegisterBuilder {
    s.discount = v
    return s
}
            

func NewConfigCellRegisterBuilder() *ConfigCellRegisterBuilder {
	return &ConfigCellRegisterBuilder{ apply_min_waiting_block_number: Uint32Default(),apply_max_waiting_block_number: Uint32Default(),account_max_length: Uint32Default(),char_sets: CharSetListDefault(),price_configs: PriceConfigListDefault(),proposal_min_confirm_interval: Uint8Default(),proposal_min_extend_interval: Uint8Default(),proposal_min_recycle_interval: Uint8Default(),proposal_max_account_affect: Uint32Default(),proposal_max_pre_account_contain: Uint32Default(),profit: ProfitConfigDefault(),discount: DiscountConfigDefault() }
}
    

type ConfigCellRegister struct {
    inner []byte
}
        

func ConfigCellRegisterFromSliceUnchecked(slice []byte) *ConfigCellRegister {
    return &ConfigCellRegister{inner: slice}
}
func (s *ConfigCellRegister) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellRegisterDefault() ConfigCellRegister {
    return *ConfigCellRegisterFromSliceUnchecked([]byte{ 139,0,0,0,52,0,0,0,56,0,0,0,60,0,0,0,64,0,0,0,68,0,0,0,72,0,0,0,73,0,0,0,74,0,0,0,75,0,0,0,79,0,0,0,83,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,36,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,8,0,0,0,0,0,0,0 })
}
            

func ConfigCellRegisterFromSlice(slice []byte, compatible bool) (*ConfigCellRegister, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellRegister", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellRegister", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 12 == 0 {
        return &ConfigCellRegister{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellRegister", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellRegister", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 12 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 12 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellRegister", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = CharSetListFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = PriceConfigListFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ProfitConfigFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DiscountConfigFromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellRegister{inner: slice}, nil
}
            

func (s *ConfigCellRegister) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellRegister) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellRegister) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellRegister) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellRegister) CountExtraFields() uint {
    return s.FieldCount() - 12
}

func (s *ConfigCellRegister) HasExtraFields() bool {
    return 12 != s.FieldCount()
}
            

func (s *ConfigCellRegister) ApplyMinWaitingBlockNumber() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) ApplyMaxWaitingBlockNumber() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) AccountMaxLength() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) CharSets() *CharSetList {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return CharSetListFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) PriceConfigs() *PriceConfigList {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return PriceConfigListFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) ProposalMinConfirmInterval() *Uint8 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) ProposalMinExtendInterval() *Uint8 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) ProposalMinRecycleInterval() *Uint8 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) ProposalMaxAccountAffect() *Uint32 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) ProposalMaxPreAccountContain() *Uint32 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) Profit() *ProfitConfig {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return ProfitConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellRegister) Discount() *DiscountConfig {
    var ret *DiscountConfig
    start := unpackNumber(s.inner[48:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[52:])
        ret = DiscountConfigFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DiscountConfigFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellRegister) AsBuilder() ConfigCellRegisterBuilder {
    ret := NewConfigCellRegisterBuilder().ApplyMinWaitingBlockNumber(*s.ApplyMinWaitingBlockNumber()).ApplyMaxWaitingBlockNumber(*s.ApplyMaxWaitingBlockNumber()).AccountMaxLength(*s.AccountMaxLength()).CharSets(*s.CharSets()).PriceConfigs(*s.PriceConfigs()).ProposalMinConfirmInterval(*s.ProposalMinConfirmInterval()).ProposalMinExtendInterval(*s.ProposalMinExtendInterval()).ProposalMinRecycleInterval(*s.ProposalMinRecycleInterval()).ProposalMaxAccountAffect(*s.ProposalMaxAccountAffect()).ProposalMaxPreAccountContain(*s.ProposalMaxPreAccountContain()).Profit(*s.Profit()).Discount(*s.Discount())
    return *ret
}
        

type PriceConfigListBuilder struct {
    inner []PriceConfig
}
    

func (s *PriceConfigListBuilder) Build() PriceConfigList {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return PriceConfigList{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return PriceConfigList{inner: b.Bytes()}
}
          

func (s *PriceConfigListBuilder) Set(v []PriceConfig) *PriceConfigListBuilder {
    s.inner = v
    return s
}
func (s *PriceConfigListBuilder) Push(v PriceConfig) *PriceConfigListBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *PriceConfigListBuilder) Extend(iter []PriceConfig) *PriceConfigListBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewPriceConfigListBuilder() *PriceConfigListBuilder {
	return &PriceConfigListBuilder{ []PriceConfig{} }
}
        

type PriceConfigList struct {
    inner []byte
}
        

func PriceConfigListFromSliceUnchecked(slice []byte) *PriceConfigList {
    return &PriceConfigList{inner: slice}
}
func (s *PriceConfigList) AsSlice() []byte {
    return s.inner
}
            

func PriceConfigListDefault() PriceConfigList {
    return *PriceConfigListFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func PriceConfigListFromSlice(slice []byte, compatible bool) (*PriceConfigList, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &PriceConfigList{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := PriceConfigFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &PriceConfigList{inner: slice}, nil
}
            

func (s *PriceConfigList) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PriceConfigList) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PriceConfigList) Len() uint {
    return s.ItemCount()
}
func (s *PriceConfigList) IsEmpty() bool {
    return s.Len() == 0
}
// if *PriceConfig is nil, index is out of bounds
func (s *PriceConfigList) Get(index uint) *PriceConfig {
    var b *PriceConfig
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = PriceConfigFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = PriceConfigFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *PriceConfigList) AsBuilder() PriceConfigListBuilder {
    size := s.ItemCount()
    t := NewPriceConfigListBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type PriceConfigBuilder struct {
    length Uint8
new Uint64
renew Uint64
}
        

func (s *PriceConfigBuilder) Build() PriceConfig {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.length.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.new.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.length.AsSlice())
b.Write(s.new.AsSlice())
b.Write(s.renew.AsSlice())
    return PriceConfig{inner: b.Bytes()}
}
                

func (s *PriceConfigBuilder) Length(v Uint8) *PriceConfigBuilder {
    s.length = v
    return s
}
            

func (s *PriceConfigBuilder) New(v Uint64) *PriceConfigBuilder {
    s.new = v
    return s
}
            

func (s *PriceConfigBuilder) Renew(v Uint64) *PriceConfigBuilder {
    s.renew = v
    return s
}
            

func NewPriceConfigBuilder() *PriceConfigBuilder {
	return &PriceConfigBuilder{ length: Uint8Default(),new: Uint64Default(),renew: Uint64Default() }
}
    

type PriceConfig struct {
    inner []byte
}
        

func PriceConfigFromSliceUnchecked(slice []byte) *PriceConfig {
    return &PriceConfig{inner: slice}
}
func (s *PriceConfig) AsSlice() []byte {
    return s.inner
}
            

func PriceConfigDefault() PriceConfig {
    return *PriceConfigFromSliceUnchecked([]byte{ 33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func PriceConfigFromSlice(slice []byte, compatible bool) (*PriceConfig, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
        return &PriceConfig{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfig", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &PriceConfig{inner: slice}, nil
}
            

func (s *PriceConfig) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PriceConfig) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PriceConfig) Len() uint {
    return s.FieldCount()
}
func (s *PriceConfig) IsEmpty() bool {
    return s.Len() == 0
}
func (s *PriceConfig) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *PriceConfig) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *PriceConfig) Length() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PriceConfig) New() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PriceConfig) Renew() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *PriceConfig) AsBuilder() PriceConfigBuilder {
    ret := NewPriceConfigBuilder().Length(*s.Length()).New(*s.New()).Renew(*s.Renew())
    return *ret
}
        

type CharSetListBuilder struct {
    inner []CharSet
}
    

func (s *CharSetListBuilder) Build() CharSetList {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return CharSetList{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return CharSetList{inner: b.Bytes()}
}
          

func (s *CharSetListBuilder) Set(v []CharSet) *CharSetListBuilder {
    s.inner = v
    return s
}
func (s *CharSetListBuilder) Push(v CharSet) *CharSetListBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *CharSetListBuilder) Extend(iter []CharSet) *CharSetListBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewCharSetListBuilder() *CharSetListBuilder {
	return &CharSetListBuilder{ []CharSet{} }
}
        

type CharSetList struct {
    inner []byte
}
        

func CharSetListFromSliceUnchecked(slice []byte) *CharSetList {
    return &CharSetList{inner: slice}
}
func (s *CharSetList) AsSlice() []byte {
    return s.inner
}
            

func CharSetListDefault() CharSetList {
    return *CharSetListFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func CharSetListFromSlice(slice []byte, compatible bool) (*CharSetList, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "CharSetList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSetList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &CharSetList{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSetList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "CharSetList", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "CharSetList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "CharSetList"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := CharSetFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &CharSetList{inner: slice}, nil
}
            

func (s *CharSetList) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *CharSetList) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *CharSetList) Len() uint {
    return s.ItemCount()
}
func (s *CharSetList) IsEmpty() bool {
    return s.Len() == 0
}
// if *CharSet is nil, index is out of bounds
func (s *CharSetList) Get(index uint) *CharSet {
    var b *CharSet
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = CharSetFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = CharSetFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *CharSetList) AsBuilder() CharSetListBuilder {
    size := s.ItemCount()
    t := NewCharSetListBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type CharSetBuilder struct {
    name Uint32
global Uint8
chars Chars
}
        

func (s *CharSetBuilder) Build() CharSet {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.name.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.global.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.chars.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.name.AsSlice())
b.Write(s.global.AsSlice())
b.Write(s.chars.AsSlice())
    return CharSet{inner: b.Bytes()}
}
                

func (s *CharSetBuilder) Name(v Uint32) *CharSetBuilder {
    s.name = v
    return s
}
            

func (s *CharSetBuilder) Global(v Uint8) *CharSetBuilder {
    s.global = v
    return s
}
            

func (s *CharSetBuilder) Chars(v Chars) *CharSetBuilder {
    s.chars = v
    return s
}
            

func NewCharSetBuilder() *CharSetBuilder {
	return &CharSetBuilder{ name: Uint32Default(),global: Uint8Default(),chars: CharsDefault() }
}
    

type CharSet struct {
    inner []byte
}
        

func CharSetFromSliceUnchecked(slice []byte) *CharSet {
    return &CharSet{inner: slice}
}
func (s *CharSet) AsSlice() []byte {
    return s.inner
}
            

func CharSetDefault() CharSet {
    return *CharSetFromSliceUnchecked([]byte{ 25,0,0,0,16,0,0,0,20,0,0,0,21,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func CharSetFromSlice(slice []byte, compatible bool) (*CharSet, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "CharSet", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSet", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
        return &CharSet{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSet", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "CharSet", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "CharSet", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = CharsFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &CharSet{inner: slice}, nil
}
            

func (s *CharSet) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *CharSet) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *CharSet) Len() uint {
    return s.FieldCount()
}
func (s *CharSet) IsEmpty() bool {
    return s.Len() == 0
}
func (s *CharSet) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *CharSet) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *CharSet) Name() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *CharSet) Global() *Uint8 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *CharSet) Chars() *Chars {
    var ret *Chars
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = CharsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = CharsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *CharSet) AsBuilder() CharSetBuilder {
    ret := NewCharSetBuilder().Name(*s.Name()).Global(*s.Global()).Chars(*s.Chars())
    return *ret
}
        

type CharsBuilder struct {
    inner []Bytes
}
    

func (s *CharsBuilder) Build() Chars {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return Chars{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return Chars{inner: b.Bytes()}
}
          

func (s *CharsBuilder) Set(v []Bytes) *CharsBuilder {
    s.inner = v
    return s
}
func (s *CharsBuilder) Push(v Bytes) *CharsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *CharsBuilder) Extend(iter []Bytes) *CharsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewCharsBuilder() *CharsBuilder {
	return &CharsBuilder{ []Bytes{} }
}
        

type Chars struct {
    inner []byte
}
        

func CharsFromSliceUnchecked(slice []byte) *Chars {
    return &Chars{inner: slice}
}
func (s *Chars) AsSlice() []byte {
    return s.inner
}
            

func CharsDefault() Chars {
    return *CharsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func CharsFromSlice(slice []byte, compatible bool) (*Chars, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &Chars{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := BytesFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &Chars{inner: slice}, nil
}
            

func (s *Chars) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Chars) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Chars) Len() uint {
    return s.ItemCount()
}
func (s *Chars) IsEmpty() bool {
    return s.Len() == 0
}
// if *Bytes is nil, index is out of bounds
func (s *Chars) Get(index uint) *Bytes {
    var b *Bytes
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = BytesFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = BytesFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *Chars) AsBuilder() CharsBuilder {
    size := s.ItemCount()
    t := NewCharsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type ProfitConfigBuilder struct {
    profit_rate_of_inviter Uint32
profit_rate_of_channel Uint32
profit_rate_of_das Uint32
profit_rate_of_proposal_create Uint32
profit_rate_of_proposal_confirm Uint32
}
        

func (s *ProfitConfigBuilder) Build() ProfitConfig {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.profit_rate_of_inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.profit_rate_of_channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.profit_rate_of_das.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.profit_rate_of_proposal_create.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.profit_rate_of_proposal_confirm.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.profit_rate_of_inviter.AsSlice())
b.Write(s.profit_rate_of_channel.AsSlice())
b.Write(s.profit_rate_of_das.AsSlice())
b.Write(s.profit_rate_of_proposal_create.AsSlice())
b.Write(s.profit_rate_of_proposal_confirm.AsSlice())
    return ProfitConfig{inner: b.Bytes()}
}
                

func (s *ProfitConfigBuilder) ProfitRateOfInviter(v Uint32) *ProfitConfigBuilder {
    s.profit_rate_of_inviter = v
    return s
}
            

func (s *ProfitConfigBuilder) ProfitRateOfChannel(v Uint32) *ProfitConfigBuilder {
    s.profit_rate_of_channel = v
    return s
}
            

func (s *ProfitConfigBuilder) ProfitRateOfDas(v Uint32) *ProfitConfigBuilder {
    s.profit_rate_of_das = v
    return s
}
            

func (s *ProfitConfigBuilder) ProfitRateOfProposalCreate(v Uint32) *ProfitConfigBuilder {
    s.profit_rate_of_proposal_create = v
    return s
}
            

func (s *ProfitConfigBuilder) ProfitRateOfProposalConfirm(v Uint32) *ProfitConfigBuilder {
    s.profit_rate_of_proposal_confirm = v
    return s
}
            

func NewProfitConfigBuilder() *ProfitConfigBuilder {
	return &ProfitConfigBuilder{ profit_rate_of_inviter: Uint32Default(),profit_rate_of_channel: Uint32Default(),profit_rate_of_das: Uint32Default(),profit_rate_of_proposal_create: Uint32Default(),profit_rate_of_proposal_confirm: Uint32Default() }
}
    

type ProfitConfig struct {
    inner []byte
}
        

func ProfitConfigFromSliceUnchecked(slice []byte) *ProfitConfig {
    return &ProfitConfig{inner: slice}
}
func (s *ProfitConfig) AsSlice() []byte {
    return s.inner
}
            

func ProfitConfigDefault() ProfitConfig {
    return *ProfitConfigFromSliceUnchecked([]byte{ 44,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,36,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ProfitConfigFromSlice(slice []byte, compatible bool) (*ProfitConfig, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProfitConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProfitConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
        return &ProfitConfig{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProfitConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ProfitConfig", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProfitConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &ProfitConfig{inner: slice}, nil
}
            

func (s *ProfitConfig) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ProfitConfig) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ProfitConfig) Len() uint {
    return s.FieldCount()
}
func (s *ProfitConfig) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ProfitConfig) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *ProfitConfig) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *ProfitConfig) ProfitRateOfInviter() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProfitConfig) ProfitRateOfChannel() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProfitConfig) ProfitRateOfDas() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProfitConfig) ProfitRateOfProposalCreate() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProfitConfig) ProfitRateOfProposalConfirm() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ProfitConfig) AsBuilder() ProfitConfigBuilder {
    ret := NewProfitConfigBuilder().ProfitRateOfInviter(*s.ProfitRateOfInviter()).ProfitRateOfChannel(*s.ProfitRateOfChannel()).ProfitRateOfDas(*s.ProfitRateOfDas()).ProfitRateOfProposalCreate(*s.ProfitRateOfProposalCreate()).ProfitRateOfProposalConfirm(*s.ProfitRateOfProposalConfirm())
    return *ret
}
        

type DiscountConfigBuilder struct {
    invited_discount Uint32
}
        

func (s *DiscountConfigBuilder) Build() DiscountConfig {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (1 + 1)
    offsets := make([]uint32, 0, 1)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.invited_discount.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.invited_discount.AsSlice())
    return DiscountConfig{inner: b.Bytes()}
}
                

func (s *DiscountConfigBuilder) InvitedDiscount(v Uint32) *DiscountConfigBuilder {
    s.invited_discount = v
    return s
}
            

func NewDiscountConfigBuilder() *DiscountConfigBuilder {
	return &DiscountConfigBuilder{ invited_discount: Uint32Default() }
}
    

type DiscountConfig struct {
    inner []byte
}
        

func DiscountConfigFromSliceUnchecked(slice []byte) *DiscountConfig {
    return &DiscountConfig{inner: slice}
}
func (s *DiscountConfig) AsSlice() []byte {
    return s.inner
}
            

func DiscountConfigDefault() DiscountConfig {
    return *DiscountConfigFromSliceUnchecked([]byte{ 12,0,0,0,8,0,0,0,0,0,0,0 })
}
            

func DiscountConfigFromSlice(slice []byte, compatible bool) (*DiscountConfig, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscountConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
        return &DiscountConfig{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DiscountConfig", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 1 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 1 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

    return &DiscountConfig{inner: slice}, nil
}
            

func (s *DiscountConfig) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DiscountConfig) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DiscountConfig) Len() uint {
    return s.FieldCount()
}
func (s *DiscountConfig) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DiscountConfig) CountExtraFields() uint {
    return s.FieldCount() - 1
}

func (s *DiscountConfig) HasExtraFields() bool {
    return 1 != s.FieldCount()
}
            

func (s *DiscountConfig) InvitedDiscount() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[4:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[8:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DiscountConfig) AsBuilder() DiscountConfigBuilder {
    ret := NewDiscountConfigBuilder().InvitedDiscount(*s.InvitedDiscount())
    return *ret
}
        

type ConfigCellMarketBuilder struct {
    primary_market MarketConfig
secondary_market MarketConfig
}
        

func (s *ConfigCellMarketBuilder) Build() ConfigCellMarket {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.primary_market.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.secondary_market.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.primary_market.AsSlice())
b.Write(s.secondary_market.AsSlice())
    return ConfigCellMarket{inner: b.Bytes()}
}
                

func (s *ConfigCellMarketBuilder) PrimaryMarket(v MarketConfig) *ConfigCellMarketBuilder {
    s.primary_market = v
    return s
}
            

func (s *ConfigCellMarketBuilder) SecondaryMarket(v MarketConfig) *ConfigCellMarketBuilder {
    s.secondary_market = v
    return s
}
            

func NewConfigCellMarketBuilder() *ConfigCellMarketBuilder {
	return &ConfigCellMarketBuilder{ primary_market: MarketConfigDefault(),secondary_market: MarketConfigDefault() }
}
    

type ConfigCellMarket struct {
    inner []byte
}
        

func ConfigCellMarketFromSliceUnchecked(slice []byte) *ConfigCellMarket {
    return &ConfigCellMarket{inner: slice}
}
func (s *ConfigCellMarket) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMarketDefault() ConfigCellMarket {
    return *ConfigCellMarketFromSliceUnchecked([]byte{ 84,0,0,0,12,0,0,0,48,0,0,0,36,0,0,0,20,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0,20,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMarketFromSlice(slice []byte, compatible bool) (*ConfigCellMarket, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMarket", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
        return &ConfigCellMarket{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMarket", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = MarketConfigFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = MarketConfigFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMarket{inner: slice}, nil
}
            

func (s *ConfigCellMarket) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMarket) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMarket) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMarket) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMarket) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ConfigCellMarket) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ConfigCellMarket) PrimaryMarket() *MarketConfig {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return MarketConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMarket) SecondaryMarket() *MarketConfig {
    var ret *MarketConfig
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = MarketConfigFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = MarketConfigFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMarket) AsBuilder() ConfigCellMarketBuilder {
    ret := NewConfigCellMarketBuilder().PrimaryMarket(*s.PrimaryMarket()).SecondaryMarket(*s.SecondaryMarket())
    return *ret
}
        

type MarketConfigBuilder struct {
    max_selling_time Uint32
max_auction_time Uint32
max_auction_waiting Uint32
min_auction_raise_rate Uint32
}
        

func (s *MarketConfigBuilder) Build() MarketConfig {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (4 + 1)
    offsets := make([]uint32, 0, 4)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.max_selling_time.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.max_auction_time.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.max_auction_waiting.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.min_auction_raise_rate.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.max_selling_time.AsSlice())
b.Write(s.max_auction_time.AsSlice())
b.Write(s.max_auction_waiting.AsSlice())
b.Write(s.min_auction_raise_rate.AsSlice())
    return MarketConfig{inner: b.Bytes()}
}
                

func (s *MarketConfigBuilder) MaxSellingTime(v Uint32) *MarketConfigBuilder {
    s.max_selling_time = v
    return s
}
            

func (s *MarketConfigBuilder) MaxAuctionTime(v Uint32) *MarketConfigBuilder {
    s.max_auction_time = v
    return s
}
            

func (s *MarketConfigBuilder) MaxAuctionWaiting(v Uint32) *MarketConfigBuilder {
    s.max_auction_waiting = v
    return s
}
            

func (s *MarketConfigBuilder) MinAuctionRaiseRate(v Uint32) *MarketConfigBuilder {
    s.min_auction_raise_rate = v
    return s
}
            

func NewMarketConfigBuilder() *MarketConfigBuilder {
	return &MarketConfigBuilder{ max_selling_time: Uint32Default(),max_auction_time: Uint32Default(),max_auction_waiting: Uint32Default(),min_auction_raise_rate: Uint32Default() }
}
    

type MarketConfig struct {
    inner []byte
}
        

func MarketConfigFromSliceUnchecked(slice []byte) *MarketConfig {
    return &MarketConfig{inner: slice}
}
func (s *MarketConfig) AsSlice() []byte {
    return s.inner
}
            

func MarketConfigDefault() MarketConfig {
    return *MarketConfigFromSliceUnchecked([]byte{ 36,0,0,0,20,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func MarketConfigFromSlice(slice []byte, compatible bool) (*MarketConfig, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "MarketConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "MarketConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
        return &MarketConfig{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "MarketConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "MarketConfig", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 4 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 4 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "MarketConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

    return &MarketConfig{inner: slice}, nil
}
            

func (s *MarketConfig) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *MarketConfig) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *MarketConfig) Len() uint {
    return s.FieldCount()
}
func (s *MarketConfig) IsEmpty() bool {
    return s.Len() == 0
}
func (s *MarketConfig) CountExtraFields() uint {
    return s.FieldCount() - 4
}

func (s *MarketConfig) HasExtraFields() bool {
    return 4 != s.FieldCount()
}
            

func (s *MarketConfig) MaxSellingTime() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *MarketConfig) MaxAuctionTime() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *MarketConfig) MaxAuctionWaiting() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *MarketConfig) MinAuctionRaiseRate() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[16:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[20:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *MarketConfig) AsBuilder() MarketConfigBuilder {
    ret := NewMarketConfigBuilder().MaxSellingTime(*s.MaxSellingTime()).MaxAuctionTime(*s.MaxAuctionTime()).MaxAuctionWaiting(*s.MaxAuctionWaiting()).MinAuctionRaiseRate(*s.MinAuctionRaiseRate())
    return *ret
}
        

type ProposalCellDataBuilder struct {
    proposer_lock Script
proposer_wallet Bytes
created_at_height Uint64
slices SliceList
}
        

func (s *ProposalCellDataBuilder) Build() ProposalCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (4 + 1)
    offsets := make([]uint32, 0, 4)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposer_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposer_wallet.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.created_at_height.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.slices.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.proposer_lock.AsSlice())
b.Write(s.proposer_wallet.AsSlice())
b.Write(s.created_at_height.AsSlice())
b.Write(s.slices.AsSlice())
    return ProposalCellData{inner: b.Bytes()}
}
                

func (s *ProposalCellDataBuilder) ProposerLock(v Script) *ProposalCellDataBuilder {
    s.proposer_lock = v
    return s
}
            

func (s *ProposalCellDataBuilder) ProposerWallet(v Bytes) *ProposalCellDataBuilder {
    s.proposer_wallet = v
    return s
}
            

func (s *ProposalCellDataBuilder) CreatedAtHeight(v Uint64) *ProposalCellDataBuilder {
    s.created_at_height = v
    return s
}
            

func (s *ProposalCellDataBuilder) Slices(v SliceList) *ProposalCellDataBuilder {
    s.slices = v
    return s
}
            

func NewProposalCellDataBuilder() *ProposalCellDataBuilder {
	return &ProposalCellDataBuilder{ proposer_lock: ScriptDefault(),proposer_wallet: BytesDefault(),created_at_height: Uint64Default(),slices: SliceListDefault() }
}
    

type ProposalCellData struct {
    inner []byte
}
        

func ProposalCellDataFromSliceUnchecked(slice []byte) *ProposalCellData {
    return &ProposalCellData{inner: slice}
}
func (s *ProposalCellData) AsSlice() []byte {
    return s.inner
}
            

func ProposalCellDataDefault() ProposalCellData {
    return *ProposalCellDataFromSliceUnchecked([]byte{ 89,0,0,0,20,0,0,0,73,0,0,0,77,0,0,0,85,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func ProposalCellDataFromSlice(slice []byte, compatible bool) (*ProposalCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
        return &ProposalCellData{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 4 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 4 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = SliceListFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

    return &ProposalCellData{inner: slice}, nil
}
            

func (s *ProposalCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ProposalCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ProposalCellData) Len() uint {
    return s.FieldCount()
}
func (s *ProposalCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ProposalCellData) CountExtraFields() uint {
    return s.FieldCount() - 4
}

func (s *ProposalCellData) HasExtraFields() bool {
    return 4 != s.FieldCount()
}
            

func (s *ProposalCellData) ProposerLock() *Script {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalCellData) ProposerWallet() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalCellData) CreatedAtHeight() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalCellData) Slices() *SliceList {
    var ret *SliceList
    start := unpackNumber(s.inner[16:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[20:])
        ret = SliceListFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = SliceListFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ProposalCellData) AsBuilder() ProposalCellDataBuilder {
    ret := NewProposalCellDataBuilder().ProposerLock(*s.ProposerLock()).ProposerWallet(*s.ProposerWallet()).CreatedAtHeight(*s.CreatedAtHeight()).Slices(*s.Slices())
    return *ret
}
        

type SliceListBuilder struct {
    inner []SL
}
    

func (s *SliceListBuilder) Build() SliceList {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return SliceList{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return SliceList{inner: b.Bytes()}
}
          

func (s *SliceListBuilder) Set(v []SL) *SliceListBuilder {
    s.inner = v
    return s
}
func (s *SliceListBuilder) Push(v SL) *SliceListBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *SliceListBuilder) Extend(iter []SL) *SliceListBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewSliceListBuilder() *SliceListBuilder {
	return &SliceListBuilder{ []SL{} }
}
        

type SliceList struct {
    inner []byte
}
        

func SliceListFromSliceUnchecked(slice []byte) *SliceList {
    return &SliceList{inner: slice}
}
func (s *SliceList) AsSlice() []byte {
    return s.inner
}
            

func SliceListDefault() SliceList {
    return *SliceListFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func SliceListFromSlice(slice []byte, compatible bool) (*SliceList, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &SliceList{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := SLFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &SliceList{inner: slice}, nil
}
            

func (s *SliceList) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SliceList) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SliceList) Len() uint {
    return s.ItemCount()
}
func (s *SliceList) IsEmpty() bool {
    return s.Len() == 0
}
// if *SL is nil, index is out of bounds
func (s *SliceList) Get(index uint) *SL {
    var b *SL
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = SLFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = SLFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *SliceList) AsBuilder() SliceListBuilder {
    size := s.ItemCount()
    t := NewSliceListBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type SLBuilder struct {
    inner []ProposalItem
}
    

func (s *SLBuilder) Build() SL {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return SL{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return SL{inner: b.Bytes()}
}
          

func (s *SLBuilder) Set(v []ProposalItem) *SLBuilder {
    s.inner = v
    return s
}
func (s *SLBuilder) Push(v ProposalItem) *SLBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *SLBuilder) Extend(iter []ProposalItem) *SLBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewSLBuilder() *SLBuilder {
	return &SLBuilder{ []ProposalItem{} }
}
        

type SL struct {
    inner []byte
}
        

func SLFromSliceUnchecked(slice []byte) *SL {
    return &SL{inner: slice}
}
func (s *SL) AsSlice() []byte {
    return s.inner
}
            

func SLDefault() SL {
    return *SLFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func SLFromSlice(slice []byte, compatible bool) (*SL, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &SL{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SL", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "SL"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := ProposalItemFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &SL{inner: slice}, nil
}
            

func (s *SL) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SL) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SL) Len() uint {
    return s.ItemCount()
}
func (s *SL) IsEmpty() bool {
    return s.Len() == 0
}
// if *ProposalItem is nil, index is out of bounds
func (s *SL) Get(index uint) *ProposalItem {
    var b *ProposalItem
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = ProposalItemFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = ProposalItemFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *SL) AsBuilder() SLBuilder {
    size := s.ItemCount()
    t := NewSLBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type ProposalItemBuilder struct {
    account_id AccountId
item_type Uint8
next AccountId
}
        

func (s *ProposalItemBuilder) Build() ProposalItem {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.item_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.next.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_id.AsSlice())
b.Write(s.item_type.AsSlice())
b.Write(s.next.AsSlice())
    return ProposalItem{inner: b.Bytes()}
}
                

func (s *ProposalItemBuilder) AccountId(v AccountId) *ProposalItemBuilder {
    s.account_id = v
    return s
}
            

func (s *ProposalItemBuilder) ItemType(v Uint8) *ProposalItemBuilder {
    s.item_type = v
    return s
}
            

func (s *ProposalItemBuilder) Next(v AccountId) *ProposalItemBuilder {
    s.next = v
    return s
}
            

func NewProposalItemBuilder() *ProposalItemBuilder {
	return &ProposalItemBuilder{ account_id: AccountIdDefault(),item_type: Uint8Default(),next: AccountIdDefault() }
}
    

type ProposalItem struct {
    inner []byte
}
        

func ProposalItemFromSliceUnchecked(slice []byte) *ProposalItem {
    return &ProposalItem{inner: slice}
}
func (s *ProposalItem) AsSlice() []byte {
    return s.inner
}
            

func ProposalItemDefault() ProposalItem {
    return *ProposalItemFromSliceUnchecked([]byte{ 37,0,0,0,16,0,0,0,26,0,0,0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ProposalItemFromSlice(slice []byte, compatible bool) (*ProposalItem, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
        return &ProposalItem{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalItem", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountIdFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ProposalItem{inner: slice}, nil
}
            

func (s *ProposalItem) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ProposalItem) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ProposalItem) Len() uint {
    return s.FieldCount()
}
func (s *ProposalItem) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ProposalItem) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ProposalItem) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ProposalItem) AccountId() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalItem) ItemType() *Uint8 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalItem) Next() *AccountId {
    var ret *AccountId
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = AccountIdFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = AccountIdFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ProposalItem) AsBuilder() ProposalItemBuilder {
    ret := NewProposalItemBuilder().AccountId(*s.AccountId()).ItemType(*s.ItemType()).Next(*s.Next())
    return *ret
}
        

type AccountCellDataBuilder struct {
    id AccountId
owner_lock Script
manager_lock Script
account AccountChars
registered_at Uint64
status Uint8
records Records
}
        

func (s *AccountCellDataBuilder) Build() AccountCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (7 + 1)
    offsets := make([]uint32, 0, 7)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.owner_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.manager_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.registered_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.records.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.id.AsSlice())
b.Write(s.owner_lock.AsSlice())
b.Write(s.manager_lock.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.registered_at.AsSlice())
b.Write(s.status.AsSlice())
b.Write(s.records.AsSlice())
    return AccountCellData{inner: b.Bytes()}
}
                

func (s *AccountCellDataBuilder) Id(v AccountId) *AccountCellDataBuilder {
    s.id = v
    return s
}
            

func (s *AccountCellDataBuilder) OwnerLock(v Script) *AccountCellDataBuilder {
    s.owner_lock = v
    return s
}
            

func (s *AccountCellDataBuilder) ManagerLock(v Script) *AccountCellDataBuilder {
    s.manager_lock = v
    return s
}
            

func (s *AccountCellDataBuilder) Account(v AccountChars) *AccountCellDataBuilder {
    s.account = v
    return s
}
            

func (s *AccountCellDataBuilder) RegisteredAt(v Uint64) *AccountCellDataBuilder {
    s.registered_at = v
    return s
}
            

func (s *AccountCellDataBuilder) Status(v Uint8) *AccountCellDataBuilder {
    s.status = v
    return s
}
            

func (s *AccountCellDataBuilder) Records(v Records) *AccountCellDataBuilder {
    s.records = v
    return s
}
            

func NewAccountCellDataBuilder() *AccountCellDataBuilder {
	return &AccountCellDataBuilder{ id: AccountIdDefault(),owner_lock: ScriptDefault(),manager_lock: ScriptDefault(),account: AccountCharsDefault(),registered_at: Uint64Default(),status: Uint8Default(),records: RecordsDefault() }
}
    

type AccountCellData struct {
    inner []byte
}
        

func AccountCellDataFromSliceUnchecked(slice []byte) *AccountCellData {
    return &AccountCellData{inner: slice}
}
func (s *AccountCellData) AsSlice() []byte {
    return s.inner
}
            

func AccountCellDataDefault() AccountCellData {
    return *AccountCellDataFromSliceUnchecked([]byte{ 165,0,0,0,32,0,0,0,42,0,0,0,95,0,0,0,148,0,0,0,152,0,0,0,160,0,0,0,161,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func AccountCellDataFromSlice(slice []byte, compatible bool) (*AccountCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
        return &AccountCellData{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 7 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 7 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountCharsFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = RecordsFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountCellData{inner: slice}, nil
}
            

func (s *AccountCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountCellData) Len() uint {
    return s.FieldCount()
}
func (s *AccountCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountCellData) CountExtraFields() uint {
    return s.FieldCount() - 7
}

func (s *AccountCellData) HasExtraFields() bool {
    return 7 != s.FieldCount()
}
            

func (s *AccountCellData) Id() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) OwnerLock() *Script {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) ManagerLock() *Script {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) Account() *AccountChars {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) RegisteredAt() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) Status() *Uint8 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) Records() *Records {
    var ret *Records
    start := unpackNumber(s.inner[28:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[32:])
        ret = RecordsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = RecordsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountCellData) AsBuilder() AccountCellDataBuilder {
    ret := NewAccountCellDataBuilder().Id(*s.Id()).OwnerLock(*s.OwnerLock()).ManagerLock(*s.ManagerLock()).Account(*s.Account()).RegisteredAt(*s.RegisteredAt()).Status(*s.Status()).Records(*s.Records())
    return *ret
}
        

type AccountIdBuilder struct {
	inner [10]Byte
}

func NewAccountIdBuilder() *AccountIdBuilder {
	return &AccountIdBuilder{inner: [10]Byte{ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault()}}
}

func (s *AccountIdBuilder) Build() AccountId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return AccountId{inner: b.Bytes()}
}
        

func (s *AccountIdBuilder) Set(v [10]Byte) *AccountIdBuilder {
	s.inner = v
	return s
}
        

func (s *AccountIdBuilder) Nth0(v Byte) *AccountIdBuilder {
	s.inner[0] = v
	return s
}
                

func (s *AccountIdBuilder) Nth1(v Byte) *AccountIdBuilder {
	s.inner[1] = v
	return s
}
                

func (s *AccountIdBuilder) Nth2(v Byte) *AccountIdBuilder {
	s.inner[2] = v
	return s
}
                

func (s *AccountIdBuilder) Nth3(v Byte) *AccountIdBuilder {
	s.inner[3] = v
	return s
}
                

func (s *AccountIdBuilder) Nth4(v Byte) *AccountIdBuilder {
	s.inner[4] = v
	return s
}
                

func (s *AccountIdBuilder) Nth5(v Byte) *AccountIdBuilder {
	s.inner[5] = v
	return s
}
                

func (s *AccountIdBuilder) Nth6(v Byte) *AccountIdBuilder {
	s.inner[6] = v
	return s
}
                

func (s *AccountIdBuilder) Nth7(v Byte) *AccountIdBuilder {
	s.inner[7] = v
	return s
}
                

func (s *AccountIdBuilder) Nth8(v Byte) *AccountIdBuilder {
	s.inner[8] = v
	return s
}
                

func (s *AccountIdBuilder) Nth9(v Byte) *AccountIdBuilder {
	s.inner[9] = v
	return s
}
                

type AccountId struct {
    inner []byte
}
        

func AccountIdFromSliceUnchecked(slice []byte) *AccountId {
    return &AccountId{inner: slice}
}
func (s *AccountId) AsSlice() []byte {
    return s.inner
}
            

func AccountIdDefault() AccountId {
    return *AccountIdFromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountIdFromSlice(slice []byte, _compatible bool) (*AccountId, error) {
    sliceLen := len(slice)
    if sliceLen != 10 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(10)}, " ")
        return nil, errors.New(errMsg)
    }
    return &AccountId{inner: slice}, nil
}
        

func (s *AccountId) RawData() []byte {
    return s.inner
}
            

func (s *AccountId) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *AccountId) Nth1() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[1:2])
    return ret
}
            

func (s *AccountId) Nth2() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[2:3])
    return ret
}
            

func (s *AccountId) Nth3() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[3:4])
    return ret
}
            

func (s *AccountId) Nth4() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[4:5])
    return ret
}
            

func (s *AccountId) Nth5() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[5:6])
    return ret
}
            

func (s *AccountId) Nth6() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[6:7])
    return ret
}
            

func (s *AccountId) Nth7() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[7:8])
    return ret
}
            

func (s *AccountId) Nth8() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[8:9])
    return ret
}
            

func (s *AccountId) Nth9() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[9:10])
    return ret
}
            

func (s *AccountId) AsBuilder() AccountIdBuilder {
	t := NewAccountIdBuilder()
	t.Nth0(*s.Nth0())
t.Nth1(*s.Nth1())
t.Nth2(*s.Nth2())
t.Nth3(*s.Nth3())
t.Nth4(*s.Nth4())
t.Nth5(*s.Nth5())
t.Nth6(*s.Nth6())
t.Nth7(*s.Nth7())
t.Nth8(*s.Nth8())
t.Nth9(*s.Nth9())
	return *t
}
        

type RecordBuilder struct {
    record_type Bytes
record_label Bytes
record_key Bytes
record_value Bytes
record_ttl Uint32
}
        

func (s *RecordBuilder) Build() Record {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_label.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_key.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_value.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_ttl.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.record_type.AsSlice())
b.Write(s.record_label.AsSlice())
b.Write(s.record_key.AsSlice())
b.Write(s.record_value.AsSlice())
b.Write(s.record_ttl.AsSlice())
    return Record{inner: b.Bytes()}
}
                

func (s *RecordBuilder) RecordType(v Bytes) *RecordBuilder {
    s.record_type = v
    return s
}
            

func (s *RecordBuilder) RecordLabel(v Bytes) *RecordBuilder {
    s.record_label = v
    return s
}
            

func (s *RecordBuilder) RecordKey(v Bytes) *RecordBuilder {
    s.record_key = v
    return s
}
            

func (s *RecordBuilder) RecordValue(v Bytes) *RecordBuilder {
    s.record_value = v
    return s
}
            

func (s *RecordBuilder) RecordTtl(v Uint32) *RecordBuilder {
    s.record_ttl = v
    return s
}
            

func NewRecordBuilder() *RecordBuilder {
	return &RecordBuilder{ record_type: BytesDefault(),record_label: BytesDefault(),record_key: BytesDefault(),record_value: BytesDefault(),record_ttl: Uint32Default() }
}
    

type Record struct {
    inner []byte
}
        

func RecordFromSliceUnchecked(slice []byte) *Record {
    return &Record{inner: slice}
}
func (s *Record) AsSlice() []byte {
    return s.inner
}
            

func RecordDefault() Record {
    return *RecordFromSliceUnchecked([]byte{ 44,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,36,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func RecordFromSlice(slice []byte, compatible bool) (*Record, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
        return &Record{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Record", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &Record{inner: slice}, nil
}
            

func (s *Record) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Record) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Record) Len() uint {
    return s.FieldCount()
}
func (s *Record) IsEmpty() bool {
    return s.Len() == 0
}
func (s *Record) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *Record) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *Record) RecordType() *Bytes {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordLabel() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordKey() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordValue() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordTtl() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *Record) AsBuilder() RecordBuilder {
    ret := NewRecordBuilder().RecordType(*s.RecordType()).RecordLabel(*s.RecordLabel()).RecordKey(*s.RecordKey()).RecordValue(*s.RecordValue()).RecordTtl(*s.RecordTtl())
    return *ret
}
        

type RecordsBuilder struct {
    inner []Record
}
    

func (s *RecordsBuilder) Build() Records {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return Records{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return Records{inner: b.Bytes()}
}
          

func (s *RecordsBuilder) Set(v []Record) *RecordsBuilder {
    s.inner = v
    return s
}
func (s *RecordsBuilder) Push(v Record) *RecordsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *RecordsBuilder) Extend(iter []Record) *RecordsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewRecordsBuilder() *RecordsBuilder {
	return &RecordsBuilder{ []Record{} }
}
        

type Records struct {
    inner []byte
}
        

func RecordsFromSliceUnchecked(slice []byte) *Records {
    return &Records{inner: slice}
}
func (s *Records) AsSlice() []byte {
    return s.inner
}
            

func RecordsDefault() Records {
    return *RecordsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func RecordsFromSlice(slice []byte, compatible bool) (*Records, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &Records{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Records", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "Records"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := RecordFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &Records{inner: slice}, nil
}
            

func (s *Records) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Records) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Records) Len() uint {
    return s.ItemCount()
}
func (s *Records) IsEmpty() bool {
    return s.Len() == 0
}
// if *Record is nil, index is out of bounds
func (s *Records) Get(index uint) *Record {
    var b *Record
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = RecordFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = RecordFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *Records) AsBuilder() RecordsBuilder {
    size := s.ItemCount()
    t := NewRecordsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type PreAccountCellDataBuilder struct {
    account AccountChars
refund_lock Script
owner_lock Script
inviter_wallet Bytes
channel_wallet Bytes
price PriceConfig
quote Uint64
invited_discount Uint32
created_at Timestamp
}
        

func (s *PreAccountCellDataBuilder) Build() PreAccountCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (9 + 1)
    offsets := make([]uint32, 0, 9)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.refund_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.owner_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_wallet.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel_wallet.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.quote.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.invited_discount.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.created_at.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account.AsSlice())
b.Write(s.refund_lock.AsSlice())
b.Write(s.owner_lock.AsSlice())
b.Write(s.inviter_wallet.AsSlice())
b.Write(s.channel_wallet.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.quote.AsSlice())
b.Write(s.invited_discount.AsSlice())
b.Write(s.created_at.AsSlice())
    return PreAccountCellData{inner: b.Bytes()}
}
                

func (s *PreAccountCellDataBuilder) Account(v AccountChars) *PreAccountCellDataBuilder {
    s.account = v
    return s
}
            

func (s *PreAccountCellDataBuilder) RefundLock(v Script) *PreAccountCellDataBuilder {
    s.refund_lock = v
    return s
}
            

func (s *PreAccountCellDataBuilder) OwnerLock(v Script) *PreAccountCellDataBuilder {
    s.owner_lock = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InviterWallet(v Bytes) *PreAccountCellDataBuilder {
    s.inviter_wallet = v
    return s
}
            

func (s *PreAccountCellDataBuilder) ChannelWallet(v Bytes) *PreAccountCellDataBuilder {
    s.channel_wallet = v
    return s
}
            

func (s *PreAccountCellDataBuilder) Price(v PriceConfig) *PreAccountCellDataBuilder {
    s.price = v
    return s
}
            

func (s *PreAccountCellDataBuilder) Quote(v Uint64) *PreAccountCellDataBuilder {
    s.quote = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InvitedDiscount(v Uint32) *PreAccountCellDataBuilder {
    s.invited_discount = v
    return s
}
            

func (s *PreAccountCellDataBuilder) CreatedAt(v Timestamp) *PreAccountCellDataBuilder {
    s.created_at = v
    return s
}
            

func NewPreAccountCellDataBuilder() *PreAccountCellDataBuilder {
	return &PreAccountCellDataBuilder{ account: AccountCharsDefault(),refund_lock: ScriptDefault(),owner_lock: ScriptDefault(),inviter_wallet: BytesDefault(),channel_wallet: BytesDefault(),price: PriceConfigDefault(),quote: Uint64Default(),invited_discount: Uint32Default(),created_at: TimestampDefault() }
}
    

type PreAccountCellData struct {
    inner []byte
}
        

func PreAccountCellDataFromSliceUnchecked(slice []byte) *PreAccountCellData {
    return &PreAccountCellData{inner: slice}
}
func (s *PreAccountCellData) AsSlice() []byte {
    return s.inner
}
            

func PreAccountCellDataDefault() PreAccountCellData {
    return *PreAccountCellDataFromSliceUnchecked([]byte{ 211,0,0,0,40,0,0,0,44,0,0,0,97,0,0,0,150,0,0,0,154,0,0,0,158,0,0,0,191,0,0,0,199,0,0,0,203,0,0,0,4,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func PreAccountCellDataFromSlice(slice []byte, compatible bool) (*PreAccountCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 9 == 0 {
        return &PreAccountCellData{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 9 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 9 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = PriceConfigFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TimestampFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

    return &PreAccountCellData{inner: slice}, nil
}
            

func (s *PreAccountCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PreAccountCellData) Len() uint {
    return s.FieldCount()
}
func (s *PreAccountCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *PreAccountCellData) CountExtraFields() uint {
    return s.FieldCount() - 9
}

func (s *PreAccountCellData) HasExtraFields() bool {
    return 9 != s.FieldCount()
}
            

func (s *PreAccountCellData) Account() *AccountChars {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) RefundLock() *Script {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) OwnerLock() *Script {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InviterWallet() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) ChannelWallet() *Bytes {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) Price() *PriceConfig {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return PriceConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) Quote() *Uint64 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InvitedDiscount() *Uint32 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) CreatedAt() *Timestamp {
    var ret *Timestamp
    start := unpackNumber(s.inner[36:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[40:])
        ret = TimestampFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = TimestampFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *PreAccountCellData) AsBuilder() PreAccountCellDataBuilder {
    ret := NewPreAccountCellDataBuilder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLock(*s.OwnerLock()).InviterWallet(*s.InviterWallet()).ChannelWallet(*s.ChannelWallet()).Price(*s.Price()).Quote(*s.Quote()).InvitedDiscount(*s.InvitedDiscount()).CreatedAt(*s.CreatedAt())
    return *ret
}
        

type AccountCharsBuilder struct {
    inner []AccountChar
}
    

func (s *AccountCharsBuilder) Build() AccountChars {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return AccountChars{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return AccountChars{inner: b.Bytes()}
}
          

func (s *AccountCharsBuilder) Set(v []AccountChar) *AccountCharsBuilder {
    s.inner = v
    return s
}
func (s *AccountCharsBuilder) Push(v AccountChar) *AccountCharsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *AccountCharsBuilder) Extend(iter []AccountChar) *AccountCharsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
    

func NewAccountCharsBuilder() *AccountCharsBuilder {
	return &AccountCharsBuilder{ []AccountChar{} }
}
        

type AccountChars struct {
    inner []byte
}
        

func AccountCharsFromSliceUnchecked(slice []byte) *AccountChars {
    return &AccountChars{inner: slice}
}
func (s *AccountChars) AsSlice() []byte {
    return s.inner
}
            

func AccountCharsDefault() AccountChars {
    return *AccountCharsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func AccountCharsFromSlice(slice []byte, compatible bool) (*AccountChars, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &AccountChars{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    itemCount := offsetFirst/4 - 1
    headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := AccountCharFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &AccountChars{inner: slice}, nil
}
            

func (s *AccountChars) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountChars) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountChars) Len() uint {
    return s.ItemCount()
}
func (s *AccountChars) IsEmpty() bool {
    return s.Len() == 0
}
// if *AccountChar is nil, index is out of bounds
func (s *AccountChars) Get(index uint) *AccountChar {
    var b *AccountChar
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:]);

        if index == s.Len()-1 {
            b = AccountCharFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = AccountCharFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *AccountChars) AsBuilder() AccountCharsBuilder {
    size := s.ItemCount()
    t := NewAccountCharsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type AccountCharBuilder struct {
    char_set_name Uint32
bytes Bytes
}
        

func (s *AccountCharBuilder) Build() AccountChar {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.char_set_name.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.bytes.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.char_set_name.AsSlice())
b.Write(s.bytes.AsSlice())
    return AccountChar{inner: b.Bytes()}
}
                

func (s *AccountCharBuilder) CharSetName(v Uint32) *AccountCharBuilder {
    s.char_set_name = v
    return s
}
            

func (s *AccountCharBuilder) Bytes(v Bytes) *AccountCharBuilder {
    s.bytes = v
    return s
}
            

func NewAccountCharBuilder() *AccountCharBuilder {
	return &AccountCharBuilder{ char_set_name: Uint32Default(),bytes: BytesDefault() }
}
    

type AccountChar struct {
    inner []byte
}
        

func AccountCharFromSliceUnchecked(slice []byte) *AccountChar {
    return &AccountChar{inner: slice}
}
func (s *AccountChar) AsSlice() []byte {
    return s.inner
}
            

func AccountCharDefault() AccountChar {
    return *AccountCharFromSliceUnchecked([]byte{ 20,0,0,0,12,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountCharFromSlice(slice []byte, compatible bool) (*AccountChar, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
        return &AccountChar{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChar", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountChar{inner: slice}, nil
}
            

func (s *AccountChar) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountChar) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountChar) Len() uint {
    return s.FieldCount()
}
func (s *AccountChar) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountChar) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *AccountChar) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *AccountChar) CharSetName() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountChar) Bytes() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountChar) AsBuilder() AccountCharBuilder {
    ret := NewAccountCharBuilder().CharSetName(*s.CharSetName()).Bytes(*s.Bytes())
    return *ret
}
        

type OnSaleCellDataBuilder struct {
    price Uint64
started_at Uint64
}
        

func (s *OnSaleCellDataBuilder) Build() OnSaleCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.started_at.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.price.AsSlice())
b.Write(s.started_at.AsSlice())
    return OnSaleCellData{inner: b.Bytes()}
}
                

func (s *OnSaleCellDataBuilder) Price(v Uint64) *OnSaleCellDataBuilder {
    s.price = v
    return s
}
            

func (s *OnSaleCellDataBuilder) StartedAt(v Uint64) *OnSaleCellDataBuilder {
    s.started_at = v
    return s
}
            

func NewOnSaleCellDataBuilder() *OnSaleCellDataBuilder {
	return &OnSaleCellDataBuilder{ price: Uint64Default(),started_at: Uint64Default() }
}
    

type OnSaleCellData struct {
    inner []byte
}
        

func OnSaleCellDataFromSliceUnchecked(slice []byte) *OnSaleCellData {
    return &OnSaleCellData{inner: slice}
}
func (s *OnSaleCellData) AsSlice() []byte {
    return s.inner
}
            

func OnSaleCellDataDefault() OnSaleCellData {
    return *OnSaleCellDataFromSliceUnchecked([]byte{ 28,0,0,0,12,0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func OnSaleCellDataFromSlice(slice []byte, compatible bool) (*OnSaleCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
        return &OnSaleCellData{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "OnSaleCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &OnSaleCellData{inner: slice}, nil
}
            

func (s *OnSaleCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *OnSaleCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *OnSaleCellData) Len() uint {
    return s.FieldCount()
}
func (s *OnSaleCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *OnSaleCellData) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *OnSaleCellData) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *OnSaleCellData) Price() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *OnSaleCellData) StartedAt() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *OnSaleCellData) AsBuilder() OnSaleCellDataBuilder {
    ret := NewOnSaleCellDataBuilder().Price(*s.Price()).StartedAt(*s.StartedAt())
    return *ret
}
        

type BiddingCellDataBuilder struct {
    market_type Uint8
starting_price Uint64
current_price Uint64
current_bidder ScriptOpt
started_at Uint64
}
        

func (s *BiddingCellDataBuilder) Build() BiddingCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.market_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.starting_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.current_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.current_bidder.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.started_at.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.market_type.AsSlice())
b.Write(s.starting_price.AsSlice())
b.Write(s.current_price.AsSlice())
b.Write(s.current_bidder.AsSlice())
b.Write(s.started_at.AsSlice())
    return BiddingCellData{inner: b.Bytes()}
}
                

func (s *BiddingCellDataBuilder) MarketType(v Uint8) *BiddingCellDataBuilder {
    s.market_type = v
    return s
}
            

func (s *BiddingCellDataBuilder) StartingPrice(v Uint64) *BiddingCellDataBuilder {
    s.starting_price = v
    return s
}
            

func (s *BiddingCellDataBuilder) CurrentPrice(v Uint64) *BiddingCellDataBuilder {
    s.current_price = v
    return s
}
            

func (s *BiddingCellDataBuilder) CurrentBidder(v ScriptOpt) *BiddingCellDataBuilder {
    s.current_bidder = v
    return s
}
            

func (s *BiddingCellDataBuilder) StartedAt(v Uint64) *BiddingCellDataBuilder {
    s.started_at = v
    return s
}
            

func NewBiddingCellDataBuilder() *BiddingCellDataBuilder {
	return &BiddingCellDataBuilder{ market_type: Uint8Default(),starting_price: Uint64Default(),current_price: Uint64Default(),current_bidder: ScriptOptDefault(),started_at: Uint64Default() }
}
    

type BiddingCellData struct {
    inner []byte
}
        

func BiddingCellDataFromSliceUnchecked(slice []byte) *BiddingCellData {
    return &BiddingCellData{inner: slice}
}
func (s *BiddingCellData) AsSlice() []byte {
    return s.inner
}
            

func BiddingCellDataDefault() BiddingCellData {
    return *BiddingCellDataFromSliceUnchecked([]byte{ 49,0,0,0,24,0,0,0,25,0,0,0,33,0,0,0,41,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func BiddingCellDataFromSlice(slice []byte, compatible bool) (*BiddingCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "BiddingCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "BiddingCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
        return &BiddingCellData{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "BiddingCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "BiddingCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := offsetFirst/4 - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
    if uint32(sliceLen) < headerSize {
        errMsg := strings.Join([]string{"HeaderIsBroken", "BiddingCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
        return nil, errors.New(errMsg)
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &BiddingCellData{inner: slice}, nil
}
            

func (s *BiddingCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *BiddingCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *BiddingCellData) Len() uint {
    return s.FieldCount()
}
func (s *BiddingCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *BiddingCellData) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *BiddingCellData) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *BiddingCellData) MarketType() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *BiddingCellData) StartingPrice() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *BiddingCellData) CurrentPrice() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *BiddingCellData) CurrentBidder() *ScriptOpt {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *BiddingCellData) StartedAt() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *BiddingCellData) AsBuilder() BiddingCellDataBuilder {
    ret := NewBiddingCellDataBuilder().MarketType(*s.MarketType()).StartingPrice(*s.StartingPrice()).CurrentPrice(*s.CurrentPrice()).CurrentBidder(*s.CurrentBidder()).StartedAt(*s.StartedAt())
    return *ret
}
        
